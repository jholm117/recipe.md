{"version":3,"sources":["parser/profile/allrecipes.ts","parser/profile/cookieandkate.ts","parser/profile/profile.ts","parser/profile/theendlessmeal.ts","parser/profile/thespruceeats.ts","parser/index.ts","components/recipe.tsx","components/url-form.tsx","components/landing-page.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["AllRecipes","domain","$","text","map","i","el","firstChild","get","trim","CookieAndKate","_i","getList","selector","TheSpruceEats","profiles","readInput","url","a","async","fetch","response","cheerio","chosenProfile","find","profile","includes","console","error","recipe","title","ingredients","directions","RecipeDisplay","idx","key","d","LinkForm","onSubmit","useState","setUrl","evt","preventDefault","type","value","size","pattern","placeholder","onChange","e","target","LandingPage","props","className","App","setRecipe","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.22d593af.chunk.js","sourcesContent":["import { Profile } from \"./profile\";\n\nexport class AllRecipes implements Profile {\n  domain = 'allrecipes.com';\n\n  title($: CheerioStatic): string {\n    return $('#recipe-main-content').text();\n  }  \n  \n  ingredients($: CheerioStatic): string[] {\n    return $('span[itemprop=recipeIngredient]').map((i, el) => $(el.firstChild).text()).get();\n  }\n\n  directions($: CheerioStatic): string[] {\n    return $('ol[itemprop=recipeInstructions] li span').map((i, el) => $(el.firstChild).text().trim()).get();\n  }\n}\n","import { Profile } from \"./profile\";\n\nexport class CookieAndKate implements Profile {\n  domain = 'cookieandkate.com';  \n  \n  directions($: CheerioStatic): string[] {\n    return $('div.tasty-recipe-instructions li').map((_i, el) => $(el).text()).get();\n  }\n  ingredients($: CheerioStatic): string[] {\n    return $('div.tasty-recipe-ingredients li').map((_i, el) => $(el).text()).get();\n  }\n  title($: CheerioStatic): string {\n    return $('h1.entry-title').text();\n  }\n}\n","\nexport interface Profile {\n  domain: string;\n  \n  directions($: CheerioStatic): string[];\n  ingredients($: CheerioStatic): string[];\n  title($: CheerioStatic): string;\n}\n\nexport function getList(selector: string, $: CheerioStatic): string[] {\n  return $(selector).map((i, el) => $(el).text().trim()).get();\n}\n\nexport function getListChild(selector: string, $: CheerioStatic): string[] {\n  return $(selector).map((i, el) => $(el.lastChild).text().trim()).get();\n}\n","import { Profile, getList } from \"./profile\";\n\n// TODO: support tree instructions\nexport class TheEndlessMeal implements Profile {\n  domain = 'theendlessmeal.com';\n  directions($: CheerioStatic): string[] {\n    return getList('div.tasty-recipes-instructions ol, div.tasty-recipes-instructions p', $);\n  }\n  ingredients($: CheerioStatic): string[] {\n    return getList('div.tasty-recipes-ingredients li', $);\n  }\n  title($: CheerioStatic): string {\n    return $('h1.post-title').text();\n  }\n}\n","import { Profile, getList } from \"./profile\";\n\nexport class TheSpruceEats implements Profile {\n  domain = 'thespruceeats.com';\n  directions($: CheerioStatic): string[] {\n    return getList('section.section--instructions ol .mntl-sc-block-html p', $);\n  }\n  ingredients($: CheerioStatic): string[] {\n    return getList('section.section--ingredients .simple-list__item', $);\n  }\n  title($: CheerioStatic): string {\n    return $('h1.heading__title').text();\n  }\n}\n","import * as cheerio from 'cheerio';\nimport { AllRecipes, CookieAndKate } from './profile';\nimport { TheSpruceEats } from './profile/thespruceeats';\nimport { Profile } from './profile/profile';\n\nexport function markdown(recipe: Recipe) {\n\n  const s = `# ${recipe.title}\\n\\n## Ingredients\\n\\n${ul(recipe.ingredients)}\\n## Directions\\n\\n${ol(recipe.directions)}`;\n\n  return s;\n}\n\nfunction ul(lst: string[]){\n  return lstToString(lst.map(el => `- ${el}`));\n}\n\nfunction ol(lst: string[]){\n  return lstToString(lst.map((el, index) => `${index+1}. ${el}`));\n}\n\nfunction lstToString(lst: string[]){\n  return lst.map(el => `${el}\\n\\n`).join('');\n}\n\nexport const profiles: Profile[] = [\n  new AllRecipes(),\n  new CookieAndKate(),\n  new TheSpruceEats(),\n];\n\nexport interface Recipe {\n  title: string;\n  ingredients: string[];\n  directions: string[];\n}\n\nexport async function readInput(url: string): Promise<Recipe | null> {\n  const response = await fetch(url);\n  const text = await response.text();\n  const $ = cheerio.load(text);\n  const chosenProfile = profiles.find((profile) => url.includes(profile.domain));\n  if(!chosenProfile){\n    console.error('url not supported', chosenProfile);\n    return null;\n  } \n\n  const recipe: Recipe = {\n    title: chosenProfile.title($),\n    ingredients: chosenProfile.ingredients($),\n    directions: chosenProfile.directions($),\n  };\n  return recipe;\n}\n","import React from \"react\";\nimport { Recipe } from \"../parser\";\n\ninterface RecipeDisplayProps {\n  recipe: Recipe;\n}\n\nexport function RecipeDisplay({recipe}: RecipeDisplayProps) {\n  const { title, ingredients, directions } = recipe;\n  return (\n    <div>\n      <h1>{title}</h1>\n      <hr />\n      <h2>Ingredients</h2>\n      <ul>{ingredients.map((i, idx) => <li key={idx}>{i}</li>)}</ul>\n      <h2>Directions</h2>\n      <ol>{directions.map((d, idx) => <li key={idx}><p>{d}</p></li>)}</ol>\n    </div>\n  );\n}\n","import React, { useState } from \"react\";\n\nexport interface LinkFormProps {\n  onSubmit(url: string): void;\n}\n\nexport function LinkForm({onSubmit}: LinkFormProps) {\n  const [url, setUrl] = useState(\"\");\n  \n  const handleSubmit = (evt: React.FormEvent<HTMLFormElement>) => {\n      evt.preventDefault();\n      onSubmit(url);\n  }\n  return (\n    <form onSubmit={handleSubmit}>\n        <input\n          type=\"url\"\n          value={url}\n          size={30}\n          pattern=\"https://.*\"\n          placeholder='https://allrecipes.com/your-recipe'\n          onChange={e => setUrl(e.target.value)}\n        />\n      <input type=\"submit\" value=\"Submit\" />\n    </form>\n  );\n}\n","import React from \"react\";\nimport { LinkFormProps, LinkForm } from \"./url-form\";\nimport { profiles } from \"../parser\";\n\ninterface LandingPageProps extends LinkFormProps {}\n\nexport function LandingPage(props: LandingPageProps){\n  return (\n    <div className=\"d-flex justify-content-around\">\n      <div>\n        <h1>recipe.md</h1>\n        <LinkForm {...props} />\n      </div>\n      <div>\n        <h2>Supported Sites</h2>\n        <ul>{profiles.map((profile) => <li key={profile.domain}>{profile.domain}</li>)}</ul>\n      </div>\n    </div>\n  );\n}\n","import React, { useState } from 'react';\nimport './App.css';\nimport { readInput, Recipe } from './parser';\nimport { RecipeDisplay } from './components/recipe';\nimport { LandingPage } from './components/landing-page';\n\nconst App: React.FC = () => {\n  const [recipe, setRecipe] = useState(null as Recipe | null);\n\n  async function onSubmit(url: string) {\n    const recipe = await readInput(url);\n    setRecipe(recipe as Recipe);\n  }\n\n  return (\n    <div className=\"App\">\n      <header className=\"App-header\">\n        <div className=\"container\">\n          {recipe ? \n          <RecipeDisplay recipe={recipe}/> : \n          <LandingPage onSubmit={onSubmit} />}\n        </div>\n      </header>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}